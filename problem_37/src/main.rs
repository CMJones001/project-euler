fn main() {
    let digits = generate_candidates();
    let res: Vec<_> = digits.iter().map(|v| sum_digits(v)).collect();

    let n_digits = res.len();
    let total: u32 = res.iter().sum();

    println!("Number of truncatable primes: {}", n_digits);
    println!("Sum of truncatable primes: {}", total);
    println!("{res:?}")
}

/// Return  a list of primes and a list of candidates, these are generated by adding digits to the
/// end of the current list of candidates.
///
/// Primes are a list of definite truncatable primes.
///
/// Candidates are a list of left-truncatable primes, they don't have to be right-truncatable
/// currently.
fn get_primes_and_candidates(vecs: Vec<Vec<u32>>) -> (Vec<Vec<u32>>, Vec<Vec<u32>>) {
    let primes = vecs
        .clone()
        .into_iter()
        .flat_map(add_valid_digit_end)
        .filter(|v| is_right_prime(v));
    let candidates = vecs.into_iter().flat_map(add_valid_digit_mid);

    (primes.collect(), candidates.collect())
}

fn generate_candidates() -> Vec<Vec<u32>> {
    let first_digits = vec![Vec::from([3]), Vec::from([7])];

    let (two_digit_primes, two_digit_candidates) = get_primes_and_candidates(first_digits);

    let (three_digit_primes, three_digit_candidates) =
        get_primes_and_candidates(two_digit_candidates);

    let (four_digit_primes, four_digit_candidates) =
        get_primes_and_candidates(three_digit_candidates);

    let (five_digit_primes, five_digit_candidates) =
        get_primes_and_candidates(four_digit_candidates);

    let (six_digit_primes, _) = get_primes_and_candidates(five_digit_candidates);

    two_digit_primes
        .into_iter()
        .chain(three_digit_primes)
        .chain(four_digit_primes)
        .chain(five_digit_primes)
        .chain(six_digit_primes)
        .collect()
}

/// Test for primalness of all the right-truncations of a number
///
/// This removes digits from the right side of the number, and checks if the remaining digits are
/// prime. Left truncation is handled by the way we generate the candidates, so we don't need to
/// check for it here.
fn is_right_prime(v: &[u32]) -> bool {
    let n_digits = v.len();

    (1..n_digits).all(|i| is_prime(sum_digits(&v[i..])))
}

fn are_digits_prime(v: &[u32]) -> bool {
    is_prime(sum_digits(v))
}

fn sum_digits(v: &[u32]) -> u32 {
    v.iter()
        .enumerate()
        .map(|(index, val)| 10_u32.pow(index as u32) * val)
        .sum()
}

fn is_prime(n: u32) -> bool {
    if n <= 3 {
        return n > 1;
    } else if n % 2 == 0 || n % 3 == 0 {
        return false;
    }

    let limit = (n as f64).sqrt() as u32;
    !(5..=limit)
        .step_by(6)
        .any(|i| n % i == 0 || n % (i + 2) == 0)
}

/// Add a valid digit to the end of the number, with the end result being left-truncatable.
///
/// This is the final digit added, and so can include the digits 2 and 5, which are not valid in
/// other positions. (But also cannot include 1 or 9 as these are not prime)
fn add_valid_digit_end(mut candidate: Vec<u32>) -> Vec<Vec<u32>> {
    let current_digits = candidate.len();

    let mut candidates = Vec::new();
    candidate.push(0);

    // This can include the digits 2 an 5 as these are only valid in the left-most digit position
    for i in [2, 3, 5, 7] {
        candidate[current_digits] = i;

        if is_valid(&candidate) && are_digits_prime(&candidate) {
            candidates.push(candidate.clone());
        }
    }

    candidates
}

/// Add a valid digit to the candidates to make them left-truncatable
///
/// The candidates are left-truncatable, but not necessarily right-truncatable.
///
/// This is not the final digit added, and so cannot include the digits 2 or 5, as these are not
/// valid in the left-most digit position.
fn add_valid_digit_mid(mut candidate: Vec<u32>) -> Vec<Vec<u32>> {
    let current_digits = candidate.len();

    let mut candidates = Vec::new();
    candidate.push(0);

    for i in [1, 3, 7, 9] {
        candidate[current_digits] = i;

        if is_valid(&candidate) && are_digits_prime(&candidate) {
            candidates.push(candidate.clone());
        }
    }

    candidates
}

/// A quick test to remove values that can't be prime
///
/// For now we check if the number is divisible by three, but this can be made more complex
fn is_valid(candidate: &[u32]) -> bool {
    let digit_sum: u32 = candidate.iter().sum();
    digit_sum % 3 != 0
}

#[cfg(test)]
mod test {
    use super::*;
    use std::vec;

    fn create_deques(vecs: Vec<&[u32]>) -> Vec<Vec<u32>> {
        let mut main_vec = Vec::new();

        for v in vecs.into_iter() {
            main_vec.push(Vec::from(v.to_owned()));
        }

        main_vec
    }

    #[test]
    fn add_valid_digits_1() {
        let digits = Vec::from([1]);

        let valid_candidates = add_valid_digit_mid(digits);

        let expected_digits = create_deques(vec![&[1, 1], &[1, 3], &[1, 7]]);

        assert_eq!(valid_candidates, expected_digits)
    }

    #[test]
    fn add_valid_digits_3() {
        let digits = Vec::from([3]);

        let valid_candidates = add_valid_digit_mid(digits);

        let expected_digits = create_deques(vec![&[3, 1], &[3, 7]]);

        assert_eq!(valid_candidates, expected_digits)
    }

    #[test]
    fn add_valid_digits_7() {
        let digits = Vec::from([7]);

        let valid_candidates = add_valid_digit_mid(digits);

        let expected_digits = create_deques(vec![&[7, 1], &[7, 3], &[7, 9]]);

        assert_eq!(valid_candidates, expected_digits)
    }

    #[test]
    fn add_valid_digits_9() {
        let digits = Vec::from([9]);

        let valid_candidates = add_valid_digit_mid(digits);

        let expected_digits = create_deques(vec![&[9, 1], &[9, 7]]);

        assert_eq!(valid_candidates, expected_digits)
    }

    #[test]
    fn add_final_digits() {
        let digits = Vec::from([7, 9, 7]);
        let valid_candidates = add_valid_digit_end(digits);

        // 5797 is not prime
        let expected_digits = create_deques(vec![&[7, 9, 7, 2], &[7, 9, 7, 3]]);

        assert_eq!(valid_candidates, expected_digits)
    }

    #[test]
    fn test_adding_digits() {
        let starting_digit = Vec::from([7]);
        let valid_candidates = add_valid_digit_mid(starting_digit);

        let expected_candidate = vec![7, 9];
        assert!(valid_candidates.contains(&expected_candidate));

        let starting_digit = expected_candidate;
        let valid_candidates = add_valid_digit_end(starting_digit);

        let expected_candidate = vec![7, 9, 7];
        assert!(valid_candidates.contains(&expected_candidate));

        let starting_digit = expected_candidate;
        let valid_candidates = add_valid_digit_end(starting_digit);

        let expected_candidate = vec![7, 9, 7, 3];
        assert!(valid_candidates.contains(&expected_candidate));
    }

    #[test]
    fn test_primes() {
        let primes = vec![
            373, 563, 593, 607, 653, 733, 947, 977, 1103, 1123, 1187, 1223, 1367, 1511, 1747, 1753,
            1907, 2287, 2417, 2677, 2903, 2963, 3307, 3313,
        ];
        assert!(primes.into_iter().all(is_prime))
    }

    #[test]
    fn is_composite() {
        let composite = vec![
            4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30, 32, 33, 34, 35,
            36, 38, 39, 40, 42, 44, 45, 46, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 60, 62, 63, 64,
            65, 66, 68, 69, 70, 72, 74, 75, 76, 77, 78, 80, 81, 82, 84, 85, 86, 87, 88, 90, 91, 92,
            93, 94, 95, 96, 98, 99, 100, 102, 104, 105, 106, 108, 110, 111,
        ];

        assert!(!composite.into_iter().any(is_prime));
    }

    #[test]
    fn test_is_left_prime() {
        let digits = [7, 9, 7, 3];

        assert!(are_digits_prime(&digits));
        assert!(is_right_prime(&digits));
    }

    #[test]
    fn test_sum_digits() {
        let digits = vec![vec![1, 9, 5, 6], vec![7, 9, 8, 6]];
        let expected_sums = vec![6591, 6897];

        for (digits, expected) in digits.iter().zip(expected_sums) {
            let total = sum_digits(digits);
            assert_eq!(total, expected);
        }
    }
}
